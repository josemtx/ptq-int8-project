\subsection*{Descripción}
El motor QSim separa: (i) ajuste de parámetros de cuantización (pesos y activaciones) y (ii) ejecución. Para pesos, \texttt{fit\_weight\_qparams} calcula escalas/puntos cero per-tensor o per-channel y \texttt{quantize\_weights} produce pesos INT8. Para activaciones, \texttt{fit\_act\_qparams} usa rangos por percentil. La ejecución cuantizada acumula en INT32 (restando puntos cero) y re-cuantiza a la salida con la razón $(s_x s_w)/s_y$, fusionando Conv+ReLU en dominio cuantizado.

El siguiente pseudocódigo resume la calibración greedy de pesos, el ajuste SA de activaciones y el forward cuantizado con fusión:

\subsection*{Calibración de pesos (greedy por capa)}
\begin{algorithm}[H]
\caption{CALIBRATE\_WEIGHTS}
\begin{algorithmic}[1]
\Require Lista de capas $L$, datos de calibración $D_{cal}$
\For{cada capa $L_i$ con pesos}
    \State $best \gets +\infty$
    \For{$scheme \in \{\text{per\_tensor}, \text{per\_channel}\}$}
        \For{$sym \in \{\text{True}, \text{False}\}$}
            \State $qW \gets \text{FIT\_WEIGHTS\_QPARAMS}(W_i, scheme, sym)$
            \State $err \gets \text{MSE}\big(L_i^{fp32}(D_{cal}), L_i^{qsim}(D_{cal}; qW)\big)$
            \If{$err < best$} \State $best \gets err$; guardar $qW$ \EndIf
        \EndFor
    \EndFor
    \State Fijar $qW$ óptimos en $L_i$
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection*{Calibración de activaciones (enfriamiento simulado)}
\begin{algorithm}[H]
\caption{CALIBRATE\_ACTS\_SA}
\begin{algorithmic}[1]
\Require Red $N$, $D_{cal}$, $D_{val}$, $\lambda$, $T_0$, $T_{min}$
\State $p \gets$ percentiles iniciales (p.\,ej., 99.0)
\State $best \gets \text{METRIC}(N,p,D_{val},\lambda)$
\State $curr \gets best$, $T \gets T_0$
\While{$T > T_{min}$}
    \State $p' \gets \text{NEIGHBOR}(p)$ \Comment{ajuste por capa $\pm \Delta p$}
    \State $m \gets \text{METRIC}(N,p',D_{val},\lambda)$
    \If{$\text{ACCEPT}(m, curr, T)$} $curr \gets m$; $p \gets p'$ \EndIf
    \If{$curr > best$} $best \gets curr$ \EndIf
    \State $T \gets \text{COOL}(T)$
\EndWhile
\State Fijar $p$ óptimos en $N$
\end{algorithmic}
\end{algorithm}

\subsection*{Forward cuantizado con fusión Conv+ReLU}
\begin{algorithm}[H]
\caption{QSIM\_FORWARD}
\begin{algorithmic}[1]
\Require Red $N$, entrada $x$
\For{cada capa $L$ en $N$}
    \State $(x_q,s_x,z_x) \gets \text{QUANTIZE}(x; qparams\_act_L)$
    \State $y_{32} \gets \text{CONV\_INT8\_INT32}(x_q, w_q, z_x, z_w) + b_{32}$
    \State $y_q \gets \text{REQUANTIZE}(y_{32}; s_x, s_w, s_y, z_y)$
    \If{$L$ tiene ReLU} $y_q \gets \text{RELU\_INT8}(y_q, z_y)$ \EndIf
    \State $x \gets \text{DEQUANTIZE}(y_q; s_y, z_y)$
\EndFor
\State \Return $x$
\end{algorithmic}
\end{algorithm}
